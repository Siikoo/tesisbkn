# -*- coding: utf-8 -*-
"""Futuro.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BLkdF9Gl9aCKB7-us41P_SqrgpYjcQyf
"""

# Descripción: Este programa utiliza RNN en su versión de LSTM
#              Para predecir el precio de cierre de BTC usando los 60 days de stock price

# Importamos las librerías

import math
import pandas_datareader as web
import numpy as np
import pandas as pd
import yfinance as yf
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import Dense, LSTM
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')

symbol = "BTC-USD"
start_date = "2016-06-12"
end_date = "2023-06-11"

# Obtener los datos históricos del Bitcoin desde Yahoo Finance
df = yf.download(symbol, start=start_date, end=end_date)
df

# Obtener el número de columnas y filas del dataset
df.shape

#Visualizar the precio de cierre
plt.figure(figsize=(16,8))
plt.title('Close Price History')
plt.plot(df['Close'])
plt.xlabel('Date', fontsize=18)
plt.ylabel('Close Price USD ($)', fontsize =18)
plt.show()

# Crear un nuevo datafrome con solo la columna de Precio de cierre
data = df.filter(['Close'])
# Convertimos el dataframe a un arrelgo numpy
dataset = data.values
# Obtenemos el número de filas para entrenar el modelo
training_data_len = math.ceil(len(dataset) * .8)

training_data_len

# Escalamos los datos
scaler  = MinMaxScaler(feature_range=(0,1))
scaled_data = scaler.fit_transform(dataset)

scaled_data

# Crear el datset de entrenamiento
# Creamos el dataset de entrenamiento a escala
train_data =scaled_data[0:training_data_len, :]
# Dividmos la data en x_train e y_train dataset
x_train = []
y_train = []

for i in range(60, len(train_data)):
  x_train.append(train_data[i-60:i, 0])
  y_train.append(train_data[i,0])
  if i<= 60:
    print(x_train)
    print(y_train)
    print()

# Convertimos el dataset de x e y_train en arreglos numpy
x_train, y_train = np.array(x_train), np.array(y_train)

# Remodelamos los datos
x_train= np.reshape(x_train, (x_train.shape[0],x_train.shape[1],1))

x_train.shape

# Creamos el Modelo LSTM
model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(x_train.shape[1],1)))
model.add(LSTM(50, return_sequences=False))
model.add(Dense(25))
model.add(Dense(1))

# Compilamos el modelo
model.compile(optimizer='adam', loss='mean_squared_error')

# Entrenamos el modelo
model.fit(x_train, y_train, batch_size=1, epochs=1)

# Crear el Dataset de prueba
# Creamos un nuevo arreglo conteniendo los valores escalados del index 
test_data = scaled_data[training_data_len -60: , :]
# Creamos los Datasets x_test e y_test
x_test = []
y_test = dataset[training_data_len:, :]
for i in range(60, len(test_data)):
  x_test.append(test_data[i-60:i, 0])

# Convertir la data a un arreglo numpy
x_test = np.array(x_test)

#Reformar la data
x_test = np.reshape(x_test, (x_test.shape[0], x_test.shape[1],1))

#Obtener el modelo con los valores predecidos
predictions = model.predict(x_test)
predictions = scaler.inverse_transform(predictions)

#Evaluar el modelo, obtner el RMSE
rmse=np.sqrt(np.mean(((predictions- y_test)**2)))
rmse

#Plot the data

train = data[:training_data_len]
valid = data[training_data_len:]
valid['Predictions'] = predictions

#visualiar los datos
plt.figure(figsize=(16,8))
plt.title('Model')
plt.xlabel('Date', fontsize=18)
plt.ylabel('Close Price USD($)', fontsize=18)
plt.plot(train['Close'])
plt.plot(valid[['Close', 'Predictions']])
plt.legend(['Train','Val', 'Predictions'], loc='lower right')
plt.show()

#Show the valid and predicte prices
valid

# Proyección de valores futuros
future_dates = pd.date_range(start=end_date, periods=7, closed='left')
future_predictions = []

last_data = scaled_data[-60:]
last_data = np.reshape(last_data, (1, 60, 1))

for _ in range(7):
    prediction = model.predict(last_data)
    future_predictions.append(prediction)
    last_data = np.roll(last_data, -1, axis=1)
    last_data[0, -1, 0] = prediction

future_predictions = np.array(future_predictions)
future_predictions = future_predictions.reshape((future_predictions.shape[0], future_predictions.shape[2]))
future_predictions = scaler.inverse_transform(future_predictions)

future_df = pd.DataFrame({'Date': future_dates, 'Predicted Price': future_predictions.flatten()})
print(future_df)